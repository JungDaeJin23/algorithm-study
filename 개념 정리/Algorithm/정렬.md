# 정렬
## 관련 용어

in-place 정렬은 원소들의 개수에 비해 충분히 무시할 만한 저장 공간만을 더 사용하는 정렬 알고리즘을 뜻한다. not in-place 정렬은 원소들의 개수에 비례하여 저장 공간을 더 사용하는 정렬 알고리즘을 뜻한다.[^inplace]

## O(n²)
### Bubble sort
[Wikipeida](https://ko.m.wikipedia.org/wiki/%EA%B1%B0%ED%92%88_%EC%A0%95%EB%A0%AC)

stable.
최선의 경우 한 번만 순회해도 된다.

```python
def bubble_sort(arr):
    for i in range(len(arr)-1, 0, -1):
        flag = 1
        for j in range(0, i):
            if arr[j] > arr[j + 1]:
                flag = 0
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
        if flag:
            return arr
    return arr
```

#### cocktail sort
[Wikipedia](https://ko.m.wikipedia.org/wiki/%EC%B9%B5%ED%85%8C%EC%9D%BC_%EC%A0%95%EB%A0%AC)

stable, burble sort 파생형

```python
def cocktail_sort(arr):
    left = 0
    right = len(arr) - 1
    while left < right:
        for j in range(left, right, 1):
            if arr[j] > arr[j + 1]:
                    arr[j], arr[j + 1] = arr[j + 1], arr[j]
        right -= 1
        for j in range(right, left, -1):
            if arr[j] < arr[j - 1]:
                    arr[j], arr[j - 1] = arr[j - 1], arr[j]
        left += 1
    return arr
```

#### comb(빗질) sort


### selection sort
[Wikipedia](https://ko.m.wikipedia.org/wiki/%EC%84%A0%ED%83%9D_%EC%A0%95%EB%A0%AC)

stable


```python
def selection_sort(arr):
    for i in range(len(arr)-1):
        min_idx = i
        for j in range(i+1, len(arr), 1):
            if arr[j] < arr[min_idx]:
                    min_idx = j
        arr[min_idx], arr[i] = arr[i], arr[min_idx]
    return arr
````

#### double selection sort
큰 값을 비교할때 등호를 넣으면 stable

```python
def double_selection_sort(arr):
    left = 0
    right = len(arr) - 1
    while left < right:
        min_idx = left
        max_idx = right
        for i in range(left, right+1):
            if arr[i] < arr[min_idx]:
                min_idx = i
            elif arr[i] >= arr[max_idx]:
                max_idx = i
        flag = 0
        if left == max_idx:
            flag += 1
        if right == min_idx:
            flag += 2
            
        if flag <= 1:
            arr[right], arr[max_idx] = arr[max_idx], arr[right]
            arr[left], arr[min_idx] = arr[min_idx], arr[left]
        elif flag == 2:
            arr[left], arr[min_idx] = arr[min_idx], arr[left]
            arr[right], arr[max_idx] = arr[max_idx], arr[right]
        else:
            arr[left], arr[right] = arr[right], arr[left]
            
        left += 1
        right -= 1
    return arr
```

#### 한번의 탐색에 동일한 값이 있다면 동시에 정렬

### insertion sort
[Wikipedia](https://ko.m.wikipedia.org/wiki/%EC%82%BD%EC%9E%85_%EC%A0%95%EB%A0%AC)

'''python
def insertion_sort(arr):
    tmp = 0
    for i in range(1, len(arr)):
        tmp = arr[i]
        
        for j in range(i-1, -1, -1):
            if arr[j] > tmp:
                arr[j], arr[j+1] = arr[j+1], arr [j]
            else:
                arr[j+1] = tmp
                break
    return arr
```

#### insertion sort with linked list

[linked list사용](https://www.google.com/amp/s/www.geeksforgeeks.org/iterative-selection-sort-for-linked-list/amp/)


```python

```

#### binary insertion sort

[^inplace]:[inplace 설명 출처](https://code-lab1.tistory.com/24)
